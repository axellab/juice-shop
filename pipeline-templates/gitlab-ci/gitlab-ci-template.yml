# GitLab CI/CD Pipeline Template
# Based on OWASP Juice Shop GitLab CI practices
# Adapt this template for your project by replacing variables and customizing jobs

# Define pipeline stages
stages:
  - validate
  - build
  - test
  - security
  - package
  - deploy
  - monitor

# Global variables
variables:
  # Customize these for your project
  PROJECT_NAME: "your-project-name"
  NODE_VERSION: "20"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  
  # Security and quality gates
  SECURITY_SCAN_ENABLED: "true"
  QUALITY_GATE_ENABLED: "true"
  
  # Deployment configuration
  STAGING_DEPLOY_ENABLED: "true"
  PRODUCTION_DEPLOY_ENABLED: "true"

# Default settings
default:
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache git curl
    - npm ci --cache .npm --prefer-offline
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - node_modules/
      - .npm/
      - frontend/node_modules/
  retry:
    max: 2
    when:
      - runner_system_failure
      - stuck_or_timeout_failure

# Pipeline validation
validate:
  stage: validate
  script:
    - echo "Validating pipeline configuration..."
    - node --version
    - npm --version
    - echo "Environment: $CI_ENVIRONMENT_NAME"
    - echo "Branch: $CI_COMMIT_REF_NAME"
    - echo "Commit: $CI_COMMIT_SHA"
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH && $CI_OPEN_MERGE_REQUESTS
      when: never
    - if: $CI_COMMIT_BRANCH

# Code quality and linting
lint:
  stage: validate
  script:
    - echo "Running code quality checks..."
    - npm run lint
    - npm run format:check
  artifacts:
    reports:
      codequality: gl-code-quality-report.json
    when: always
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# Build application
build:
  stage: build
  script:
    - echo "Building application..."
    - npm run build
    - npm run build:frontend
  artifacts:
    paths:
      - build/
      - frontend/dist/
    expire_in: 1 day
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# Unit tests
test:unit:
  stage: test
  script:
    - echo "Running unit tests..."
    - npm run test:unit -- --coverage --ci
  artifacts:
    paths:
      - coverage/
    reports:
      junit: test-results/unit/junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    expire_in: 1 week
  coverage: '/Lines\s*:\s*(\d+\.\d+)%/'
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# Integration tests
test:integration:
  stage: test
  services:
    - postgres:13-alpine
    - redis:6-alpine
  variables:
    POSTGRES_DB: test_db
    POSTGRES_USER: test_user
    POSTGRES_PASSWORD: test_password
    DATABASE_URL: postgres://test_user:test_password@postgres:5432/test_db
    REDIS_URL: redis://redis:6379
  script:
    - echo "Running integration tests..."
    - npm run test:integration
  artifacts:
    paths:
      - test-results/integration/
    reports:
      junit: test-results/integration/junit.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# API tests
test:api:
  stage: test
  services:
    - name: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      alias: app
  variables:
    API_BASE_URL: http://app:3000
  script:
    - echo "Running API tests..."
    - npm run test:api
  artifacts:
    paths:
      - test-results/api/
    reports:
      junit: test-results/api/junit.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# End-to-end tests
test:e2e:
  stage: test
  image: cypress/included:latest
  services:
    - name: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
      alias: app
  variables:
    CYPRESS_baseUrl: http://app:3000
  script:
    - echo "Running E2E tests..."
    - cypress run --record --key $CYPRESS_RECORD_KEY
  artifacts:
    paths:
      - cypress/videos/
      - cypress/screenshots/
    reports:
      junit: cypress/results/junit.xml
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH

# Security scanning
include:
  - template: Security/SAST.gitlab-ci.yml
  - template: Security/Dependency-Scanning.gitlab-ci.yml
  - template: Security/Container-Scanning.gitlab-ci.yml
  - template: Security/DAST.gitlab-ci.yml
  - template: Security/Secret-Detection.gitlab-ci.yml

# Custom security scans
security:custom:
  stage: security
  image: alpine:latest
  before_script:
    - apk add --no-cache curl npm
  script:
    - echo "Running custom security scans..."
    - npm audit --audit-level=moderate
    - curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin
    - grype $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    paths:
      - security-results/
    reports:
      sast: gl-sast-report.json
      dependency_scanning: gl-dependency-scanning-report.json
    expire_in: 1 week
  rules:
    - if: $SECURITY_SCAN_ENABLED == "true"

# Code quality with SonarQube
sonarqube-check:
  stage: security
  image: sonarsource/sonar-scanner-cli:latest
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - sonar-scanner
  allow_failure: true
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Build Docker image
build:docker:
  stage: package
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA $CI_REGISTRY_IMAGE:latest
    - docker push $CI_REGISTRY_IMAGE:latest
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_COMMIT_TAG

# Deploy to staging
deploy:staging:
  stage: deploy
  image: alpine:latest
  environment:
    name: staging
    url: $STAGING_URL
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to staging environment..."
    - echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
    - echo "Environment: staging"
    # Add your deployment commands here
    # Example: kubectl set image deployment/app app=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - sleep 10  # Simulate deployment
    - curl -f $STAGING_URL/health || exit 1
  rules:
    - if: $CI_COMMIT_BRANCH == "develop" && $STAGING_DEPLOY_ENABLED == "true"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $STAGING_DEPLOY_ENABLED == "true"

# Deploy to production
deploy:production:
  stage: deploy
  image: alpine:latest
  environment:
    name: production
    url: $PRODUCTION_URL
  before_script:
    - apk add --no-cache curl
  script:
    - echo "Deploying to production environment..."
    - echo "Image: $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
    - echo "Environment: production"
    # Add your deployment commands here
    # Example: kubectl set image deployment/app app=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - sleep 10  # Simulate deployment
    - curl -f $PRODUCTION_URL/health || exit 1
  when: manual
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $PRODUCTION_DEPLOY_ENABLED == "true"
    - if: $CI_COMMIT_TAG

# Post-deployment tests
test:staging:
  stage: monitor
  environment:
    name: staging
    url: $STAGING_URL
  script:
    - echo "Running post-deployment tests on staging..."
    - curl -f $STAGING_URL/health
    - npm run test:smoke
  variables:
    TEST_URL: $STAGING_URL
  rules:
    - if: $CI_COMMIT_BRANCH == "develop" && $STAGING_DEPLOY_ENABLED == "true"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $STAGING_DEPLOY_ENABLED == "true"

test:production:
  stage: monitor
  environment:
    name: production
    url: $PRODUCTION_URL
  script:
    - echo "Running post-deployment tests on production..."
    - curl -f $PRODUCTION_URL/health
    - npm run test:smoke
  variables:
    TEST_URL: $PRODUCTION_URL
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH && $PRODUCTION_DEPLOY_ENABLED == "true"
    - if: $CI_COMMIT_TAG

# Performance monitoring
monitor:performance:
  stage: monitor
  image: alpine:latest
  script:
    - echo "Setting up performance monitoring..."
    - apk add --no-cache curl
    - curl -f $PRODUCTION_URL/health
    # Add performance monitoring setup
    - echo "Performance monitoring configured"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Cleanup old artifacts
cleanup:
  stage: monitor
  image: alpine:latest
  script:
    - echo "Cleaning up old artifacts..."
    # Add cleanup commands here
    - echo "Cleanup completed"
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  when: always